#!/usr/bin/env bash

set -ue

SLJAIL_SELF_NAME="$(basename "${0}")"

: "${XDG_RUNTIME_DIR:="/run/user/$(id -u)"}"
: "${XDG_DATA_HOME:="${HOME}/.local/share"}"
: "${XDG_STATE_HOME:="${HOME}/.local/state"}"
: "${XDG_CACHE_HOME:="${HOME}/.cache"}"
: "${XDG_CONFIG_HOME:="${HOME}/.config"}"

: "${SLJAIL_STATE_HOME:="${XDG_STATE_HOME}/sljail"}"
: "${SLJAIL_RUNTIME_DIR:="${XDG_RUNTIME_DIR}/sljail"}"

SLJAIL_INSTANCE_NAME=
SLJAIL_INSTANCE_HOME=
SLJAIL_INSTANCE_USER_HOME=
SLJAIL_INSTANCE_RUNTIME_DIR=

SANDBOX_USER="${USER}"
SANDBOX_UID=1000
SANDBOX_GID=1000
SANDBOX_HOSTNAME="$(cat '/etc/hostname')"
SANDBOX_XDG_RUNTIME_DIR="/run/user/${SANDBOX_UID}"
SANDBOX_HOME="/home/${SANDBOX_USER}"
SANDBOX_XDG_DATA_HOME="${SANDBOX_HOME}/.local/share"
SANDBOX_XDG_STATE_HOME="${SANDBOX_HOME}/.local/state"
SANDBOX_XDG_CACHE_HOME="${SANDBOX_HOME}/.cache"
SANDBOX_XDG_CONFIG_HOME="${SANDBOX_HOME}/.config"

say() {
	printf '%s: %s\n' "${SLJAIL_SELF_NAME}" "${1}" >&2
}

next_fd() {
  { seq 0 255; ls -1 "/proc/${$}/fd"; } | sort -n | uniq -u | head -1
}

# add bubblewrap argument
# example:
#   arg symlink '/usr/lib' '/lib'      # symlink '/usr/lib' to '/lib' inside the sandbox
#   arg unshare-all                    # unshare all namespaces
arg() {
  local arg_name="${1}"
  shift
  bwrap_args+=("--${arg_name}" ${@})
}

# repeat the arg with all the other args - for glob binds 
# example:
#   arg2 ro-bind-try '/usr' '/etc'     # bind '/usr' to '/usr', and '/etc' to '/etc'
#   arg2 dev-bind-try '/dev/nvidia'*   # bind all /dev/nvidia* devices
arg2() {
  local arg_name="${1}"
	shift
	for bind_arg in "${@}"; do
		arg "${arg_name}" "${bind_arg}" "${bind_arg}"
	done
}

# change username and home directory inside of the sandbox 
user() {
  SANDBOX_USER="${1}"
  SANDBOX_HOME="/home/${SANDBOX_USER}"
  SANDBOX_XDG_DATA_HOME="${SANDBOX_HOME}/.local/share"
  SANDBOX_XDG_STATE_HOME="${SANDBOX_HOME}/.local/state"
  SANDBOX_XDG_CACHE_HOME="${SANDBOX_HOME}/.cache"
  SANDBOX_XDG_CONFIG_HOME="${SANDBOX_HOME}/.config"
  arg dir "${SANDBOX_HOME}"
  arg setenv 'HOME' "/home/${SANDBOX_USER}"
  arg chdir "/home/${SANDBOX_USER}"
}

# spoof machine-id
# argument should be 32-digit lowercase hex number
# if no arguments supplied, random id is generated for you
machine-id() {
  local machine_id="${arg:-"$(tr -dc '[:digit:]abcdef' < '/dev/urandom' | head -c 32)"}"
  exec {fd}< <(printf '%s' "${machine_id}")
  arg bind-data "${fd}" '/etc/machine-id'
}

# spoof /etc/passwd file
passwd() {
  local passwd="$(cat <<EOF
  root:x:0:0::/root:/bin/bash
  ${SANDBOX_USER}:x:${SANDBOX_UID}:${SANDBOX_GID}::${SANDBOX_HOME}:/bin/sh
  nobody:x:65534:65534:Nobody:/:/usr/bin/nologin
EOF
  )"
  exec {fd}< <(printf '%s' "${passwd}")
  arg bind-data "${fd}" '/etc/passwd'
}

# spoof /etc/group file
group() {
  local group="$(cat <<EOF
    root:x:0:root
    ${SANDBOX_USER}:x:${SANDBOX_GID}:${SANDBOX_USER}
    nobody:x:65534:
EOF
  )"
  exec {fd}< <(printf '%s' "${group}")
  arg bind-data "${fd}" '/etc/group'
}

# set localtime
# example:
#   localtime '/usr/share/zoneinfo/Turkey'
localtime() {
  exec {fd}<"${1}"
  arg bind-data "${fd}" '/etc/localtime'
}

# set hostname
# example:
#   hostname 'sandboxed-pc'
hostname() {
  SANDBOX_HOSTNAME="${1}"
  exec {fd}< <(printf '%s' "${SANDBOX_HOSTNAME}")
  arg bind-data "${fd}" '/etc/hostname'
}

# spoof /etc/hosts file
hosts() {
  local hosts="$(cat <<EOF
    127.0.0.1	localhost
    ::1		localhost
    127.0.0.1	${SANDBOX_HOSTNAME}.localdomain	${SANDBOX_HOSTNAME}
EOF
  )"
  exec {fd}< <(printf '%s' "${hosts}")
  arg bind-data "${fd}" '/etc/hosts'
}

# spoof /etc/host.conf file
host.conf() {
  local host_conf="$(cat <<EOF
  multi on
EOF
  )"
  exec {fd}< <(printf '%s' "${host_conf}")
  arg bind-data "${fd}" '/etc/host.conf'
}

nsswitch.conf() {
  local nsswitch_conf="$(cat <<EOF
    passwd: files
    group: files
    shadow: files

    publickey: files

    hosts: files myhostname dns
    networks: files

    protocols: files
    services: files
    ethers: files
    rpc: files

    netgroup: files
EOF
  )"
  exec {fd}< <(printf '%s' "${nsswitch_conf}")
  arg bind-data "${fd}" '/etc/nsswitch.conf'
}

dbus-system() {
  enable_dbus_system=true
  arg bind "${XDG_RUNTIME_DIR}/sljail/${SLJAIL_INSTANCE_NAME}/dbus_system_proxy" '/var/run/dbus/system_bus_socket' 
  arg bind "${XDG_RUNTIME_DIR}/sljail/${SLJAIL_INSTANCE_NAME}/dbus_system_proxy" '/run/dbus/system_bus_socket' 
}

dbus-user() {
  enable_dbus_user=true
  arg setenv 'DBUS_SESSION_BUS_ADDRESS' "unix:path=${SANDBOX_XDG_RUNTIME_DIR}/bus" 
  arg bind "${XDG_RUNTIME_DIR}/sljail/${SLJAIL_INSTANCE_NAME}/dbus_session_proxy" '/run/user/1000/bus' 
}

seccomp() {
  exec {fd}<"${1}"
  arg seccomp "${fd}"
}

name() {
  SLJAIL_INSTANCE_NAME="${1}"
  SLJAIL_INSTANCE_HOME="${SLJAIL_STATE_HOME}/${SLJAIL_INSTANCE_NAME}"
  SLJAIL_INSTANCE_USER_HOME="${SLJAIL_INSTANCE_HOME}/home"
  SLJAIL_INSTANCE_RUNTIME_DIR="${SLJAIL_RUNTIME_DIR}/${SLJAIL_INSTANCE_NAME}"
}

# Reset all variables that might be set
profile=
verbose=0 # Variables to be evaluated as shell arithmetic should be initialized to a default or validated beforehand.

while :; do
  case "${1-}" in
    -h|-\?|--help)   # Call a "usage" function to display a synopsis, then exit.
      usage
      exit
      ;;
    -p | --profile)
      profile=${2-}
      shift
      [ -z "${profile}" ] && say 'ERROR: "--profile" requires a non-empty option argument.' && exit 1
      ;;
    -n | --name)
      name "${2-}"
      shift
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;
    --)              # End of all options.
      shift
      break
      ;;
    -?*)
      say "ERROR: unknown option: ${1}"
      ;;
    *)               # Default case: If no more options then break out of the loop.
      break
  esac

  shift
done

# validate arguments
[ -z "${profile}" ] && say 'ERROR: --profile is required.' && exit 1
[ -z "${SLJAIL_INSTANCE_NAME}" ] && say 'ERROR: sljail instance is required to have a name. Either pass it through the --name argument, or specify it in the profile.' && exit 1

# initialize args arrays
bwrap_args=()
dbus_system_args=()
dbus_user_args=()

################################################################################

# source the profile
# shellcheck disable=1090
source "${profile}"

################################################################################

# positional arguments
program="${1}" && shift

# setup args for xdg dbus proxy
exec {fd}<>"$(mktemp)"
xdg_dbus_proxy_args=(--fd="${fd}")
[ "${enable_dbus_system}" = true ] && mkdir -p "${SLJAIL_INSTANCE_RUNTIME_DIR}" && xdg_dbus_proxy_args+=(
  unix:path="/run/dbus/system_bus_socket"
  "${SLJAIL_INSTANCE_RUNTIME_DIR}/dbus_system_proxy"
  --filter "${dbus_system_args[@]}"
)
[ "${enable_dbus_user}" = true ] && mkdir -p "${SLJAIL_INSTANCE_RUNTIME_DIR}" && xdg_dbus_proxy_args+=(
  unix:path="${XDG_RUNTIME_DIR}/bus"
  "${SLJAIL_INSTANCE_RUNTIME_DIR}/dbus_session_proxy"
  --filter "${dbus_user_args[@]}"
)

# start xdg dbus proxy
if [ "${enable_dbus_system}" = true ] || [ "${enable_dbus_user}" = true ]; then
  xdg-dbus-proxy "${xdg_dbus_proxy_args[@]}" &
  xdg_dbus_proxy_pid="${!}"
fi

# wait for proxies
# read _ <&"${fd}"
# printf 'after\n'

sleep 3

trap "kill ${xdg_dbus_proxy_pid}" EXIT TERM HUP

# execute bwrap with the arguments
if [ -z "${DEBUG-}" ]; then 
  bwrap "${bwrap_args[@]}" -- "${program}" "${@}"
else
  echo "${bwrap_args[@]}" | sed 's/--/\n--/g'
  echo "${program}" "${@}"
fi
