#!/usr/bin/env bash
# shellcheck disable=2016,2155

set -u

# host environment
: "${XDG_RUNTIME_DIR:="/run/user/$(id -u)"}"
: "${XDG_DATA_HOME:="${HOME}/.local/share"}"
: "${XDG_STATE_HOME:="${HOME}/.local/state"}"
: "${XDG_CACHE_HOME:="${HOME}/.cache"}"
: "${XDG_CONFIG_HOME:="${HOME}/.config"}"
: "${DBUS_SESSION_BUS_ADDRESS:="unix:path=${XDG_RUNTIME_DIR}/bus"}"

# sljail common environment
SLJAIL_SELF_NAME="$(basename "${0}")"
: "${SLJAIL_STATE_HOME:="${XDG_STATE_HOME}/sljail"}"
: "${SLJAIL_RUNTIME_DIR:="${XDG_RUNTIME_DIR}/sljail"}"
: "${SLJAIL_CACHE_HOME:="${XDG_CACHE_HOME}/sljail"}"
SLJAIL_GCC_ARGS=(-Wall -Wextra -lseccomp)

# sljail instance environment
SLJAIL_INSTANCE_NAME=
SLJAIL_INSTANCE_HOME=
SLJAIL_INSTANCE_USER_HOME=
SLJAIL_INSTANCE_RUNTIME_DIR=

# would-be environment inside the sandbox 
# (the normal names but prefixed with 'SANDBOX_')
SANDBOX_USER="${USER}"
SANDBOX_UID=1000
SANDBOX_GID=1000
SANDBOX_HOSTNAME="$(cat '/etc/hostname')"
SANDBOX_XDG_RUNTIME_DIR="/run/user/${SANDBOX_UID}"
SANDBOX_HOME="/home/${SANDBOX_USER}"
SANDBOX_XDG_DATA_HOME="${SANDBOX_HOME}/.local/share"
SANDBOX_XDG_STATE_HOME="${SANDBOX_HOME}/.local/state"
SANDBOX_XDG_CACHE_HOME="${SANDBOX_HOME}/.cache"
SANDBOX_XDG_CONFIG_HOME="${SANDBOX_HOME}/.config"
SANDBOX_DBUS_SESSION_BUS_ADDRESS="${SANDBOX_XDG_RUNTIME_DIR}/bus"

say() {
	printf '%s: %s\n' "${SLJAIL_SELF_NAME}" "${1}" >&2
}

usage() {
  printf >&2 'usage: %s [OPTIONS...] [--] COMMAND [ARGS...]\n' "${SLJAIL_SELF_NAME}"
  printf >&2 'flags:\n'
  printf >&2 '  --help         Print this help\n'
  printf >&2 '  --profile      Specify profile file\n'
  printf >&2 '  --name         Specify instance name\n'
}

# add bubblewrap argument
# example:
#   arg symlink '/usr/lib' '/lib'      # symlink '/usr/lib' to '/lib' inside the sandbox
#   arg unshare-all                    # unshare all namespaces
arg() {
  local arg_name="${1}"
  shift
  # shellcheck disable=2206
  bwrap_args+=("--${arg_name}" ${@})
}

# repeat the arg with all the other args - for glob binds 
# example:
#   arg2 ro-bind-try '/usr' '/etc'     # bind '/usr' to '/usr', and '/etc' to '/etc'
#   arg2 dev-bind-try '/dev/nvidia'*   # bind all /dev/nvidia* devices
arg2() {
  local arg_name="${1}"
	shift
	for bind_arg in "${@}"; do
		arg "${arg_name}" "${bind_arg}" "${bind_arg}"
	done
}

# change username and home directory inside of the sandbox 
# shellcheck disable=2034
user() {
  SANDBOX_USER="${1}"
  SANDBOX_HOME="/home/${SANDBOX_USER}"
  SANDBOX_XDG_DATA_HOME="${SANDBOX_HOME}/.local/share"
  SANDBOX_XDG_STATE_HOME="${SANDBOX_HOME}/.local/state"
  SANDBOX_XDG_CACHE_HOME="${SANDBOX_HOME}/.cache"
  SANDBOX_XDG_CONFIG_HOME="${SANDBOX_HOME}/.config"
  arg dir "${SANDBOX_HOME}"
  arg setenv 'HOME' "/home/${SANDBOX_USER}"
  arg chdir "/home/${SANDBOX_USER}"
}

# spoof machine-id
# argument should be 32-digit lowercase hex number
# if no arguments supplied, random id is generated for you
machine-id() {
  local machine_id="${arg:-"$(tr -dc '[:digit:]abcdef' < '/dev/urandom' | head -c 32)"}"
  exec {fd}< <(printf '%s' "${machine_id}")
  arg bind-data "${fd}" '/etc/machine-id'
}

# spoof /etc/passwd file
passwd() {
  local passwd="$(cat <<EOF
root:x:0:0::/root:/bin/bash
${SANDBOX_USER}:x:${SANDBOX_UID}:${SANDBOX_GID}::${SANDBOX_HOME}:/bin/sh
nobody:x:65534:65534:Nobody:/:/usr/bin/nologin
EOF
  )"
  exec {fd}< <(printf '%s' "${passwd}")
  arg bind-data "${fd}" '/etc/passwd'
}

# spoof /etc/group file
group() {
  local group="$(cat <<EOF
root:x:0:root
${SANDBOX_USER}:x:${SANDBOX_GID}:${SANDBOX_USER}
nobody:x:65534:
EOF
  )"
  exec {fd}< <(printf '%s' "${group}")
  arg bind-data "${fd}" '/etc/group'
}

# set localtime
# example:
#   localtime '/usr/share/zoneinfo/Turkey'
localtime() {
  exec {fd}<"${1}"
  arg bind-data "${fd}" '/etc/localtime'
}

# set hostname
# example:
#   hostname 'sandboxed-pc'
hostname() {
  SANDBOX_HOSTNAME="${1}"
  exec {fd}< <(printf '%s' "${SANDBOX_HOSTNAME}")
  arg bind-data "${fd}" '/etc/hostname'
}

# spoof /etc/hosts file
hosts() {
  local hosts="$(cat <<EOF
127.0.0.1	localhost
::1		localhost
127.0.0.1	${SANDBOX_HOSTNAME}.localdomain	${SANDBOX_HOSTNAME}
EOF
  )"
  exec {fd}< <(printf '%s' "${hosts}")
  arg bind-data "${fd}" '/etc/hosts'
}

# spoof /etc/host.conf file
host.conf() {
  local host_conf="$(cat <<EOF
multi on
EOF
  )"
  exec {fd}< <(printf '%s' "${host_conf}")
  arg bind-data "${fd}" '/etc/host.conf'
}

# spoof /etc/nsswitch.conf file
nsswitch.conf() {
  local nsswitch_conf="$(cat <<EOF
passwd: files
group: files
shadow: files

publickey: files

hosts: files myhostname dns
networks: files

protocols: files
services: files
ethers: files
rpc: files

netgroup: files
EOF
  )"
  exec {fd}< <(printf '%s' "${nsswitch_conf}")
  arg bind-data "${fd}" '/etc/nsswitch.conf'
}

dbus-system() {
  enable_dbus_system=true
  arg bind "${XDG_RUNTIME_DIR}/sljail/${SLJAIL_INSTANCE_NAME}/dbus_system_proxy" '/var/run/dbus/system_bus_socket' 
  arg bind "${XDG_RUNTIME_DIR}/sljail/${SLJAIL_INSTANCE_NAME}/dbus_system_proxy" '/run/dbus/system_bus_socket' 
}

dbus-user() {
  enable_dbus_user=true
  arg setenv 'DBUS_SESSION_BUS_ADDRESS' "${DBUS_SESSION_BUS_ADDRESS}" 
  # FIXME: hardcoded dbus path
  arg bind "${XDG_RUNTIME_DIR}/sljail/${SLJAIL_INSTANCE_NAME}/dbus_session_proxy" "${SANDBOX_DBUS_SESSION_BUS_ADDRESS}" 
}

# use precompiled bpf file as a seccomp-bpf filter of the sandbox
seccomp-precompiled() {
  exec {fd}<"${1}"
  arg seccomp "${fd}"
}

# use a C source file that exports seccomp-bpf filter to stdout as a
# seccomp-bpf filter of the sandbox
seccomp() {
  local seccomp_profile="${1}" # /home/pr/sljail/seccomp/default.c
  local seccomp_profile_name="$(basename "${seccomp_profile}")" # default.c
  local seccomp_profile_name="${seccomp_profile_name%.c}" # default
  local binary="${SLJAIL_CACHE_HOME}/seccomp/$(sha256sum "${seccomp_profile}" | cut -d' ' -f1)-${seccomp_profile_name}" # /home/.cache/sljail/seccomp/aabbccddeeff001122334455-default
  if ! [ -f "${binary}" ]; then
    mkdir -p "$(dirname "${binary}")"
    gcc "${SLJAIL_GCC_ARGS[@]}" -o "${binary}" "${seccomp_profile}"
    "${binary}" > "${binary}.bpf"
  fi
  exec {fd}<"${binary}.bpf"
  arg seccomp "${fd}"
}

# set the name of this instance. will influence things like it's runtime dir and state dir (home jail), etc.
# shellcheck disable=2034
name() {
  SLJAIL_INSTANCE_NAME="${1}"
  SLJAIL_INSTANCE_HOME="${SLJAIL_STATE_HOME}/${SLJAIL_INSTANCE_NAME}"
  SLJAIL_INSTANCE_USER_HOME="${SLJAIL_INSTANCE_HOME}/home"
  SLJAIL_INSTANCE_RUNTIME_DIR="${SLJAIL_RUNTIME_DIR}/${SLJAIL_INSTANCE_NAME}"
}

# Reset all variables that might be set
profile=
verbose=0 # Variables to be evaluated as shell arithmetic should be initialized to a default or validated beforehand.

while :; do
  case "${1-}" in
    -h|-\?|--help)   # Call a "usage" function to display a synopsis, then exit.
      usage
      exit
      ;;
    -p | --profile)
      profile=${2-}
      shift
      [ -z "${profile}" ] && say 'ERROR: `--profile` requires a non-empty option argument.' && exit 1
      ;;
    -n | --name)
      [ -z "${2-}" ] && say 'ERROR: `--name` requires a non-empty option argument.' && exit 1
      name "${2-}"
      shift
      ;;
    -v|--verbose)
      verbose=$((verbose + 1)) # Each -v argument adds 1 to verbosity.
      ;;
    --)              # End of all options.
      shift
      break
      ;;
    -?*)
      say "ERROR: unknown option: ${1}"
      ;;
    *)               # Default case: If no more options then break out of the loop.
      break
  esac

  shift
done

# validate arguments
[ -z "${profile}" ] && say 'ERROR: `--profile` is required.' && exit 1
[ -z "${SLJAIL_INSTANCE_NAME}" ] && say 'ERROR: sljail instance is required to have a name. Either pass it through the `--name` argument, or specify it in the profile with the `name` command.' && exit 1

# initialize args arrays
bwrap_args=()
dbus_system_args=()
dbus_user_args=()

################################################################################

# source the profile
# shellcheck disable=1090
source "${profile}"

################################################################################

# positional arguments
[ -z "${1-}" ] && say 'ERROR: `COMMAND` is required' && usage && exit 1
program="${1}" && shift

# start xdg dbus proxy
if [ -z "${DEBUG-}" ] && { [ "${enable_dbus_system}" = true ] || [ "${enable_dbus_user}" = true ]; }; then
  # setup args for xdg dbus proxy
  pipe="$(mktemp -u)"
  mkfifo "${pipe}"
  exec {xdg_dbus_proxy_fd}<>"${pipe}"
  rm "${pipe}"
  xdg_dbus_proxy_args=(
    --fd="${xdg_dbus_proxy_fd}"
  )
  [ "${enable_dbus_system}" = true ] && xdg_dbus_proxy_args+=(
    'unix:path=/run/dbus/system_bus_socket'
    "${SLJAIL_INSTANCE_RUNTIME_DIR}/dbus_system_proxy"
    --filter "${dbus_system_args[@]}"
    --log
  )
  [ "${enable_dbus_user}" = true ] && xdg_dbus_proxy_args+=(
    "${DBUS_SESSION_BUS_ADDRESS}"
    "${SLJAIL_INSTANCE_RUNTIME_DIR}/dbus_session_proxy"
    --filter "${dbus_user_args[@]}"
    --log
  )

  mkdir -p "${SLJAIL_INSTANCE_RUNTIME_DIR}"
  xdg-dbus-proxy "${xdg_dbus_proxy_args[@]}" &
  xdg_dbus_proxy_pid="${!}"
  # shellcheck disable=2064
  trap "kill ${xdg_dbus_proxy_pid}" EXIT TERM HUP

  # wait for proxies
  #sleep 3
  read -N 1 -r -u "${xdg_dbus_proxy_fd}" _byte
  [ -n "${DEBUG-}" ] && {
    say "xdg-dbus-proxy fd = ${xdg_dbus_proxy_fd}"
    say "xdg-dbus-proxy args = ${xdg_dbus_proxy_args[*]}"
    say "xdg-dbus-proxy byte = ${_byte}"
  }
fi

# execute bwrap with the arguments or print arguments if DEBUG
if [ -z "${DEBUG-}" ]; then 
  # DANGER: rm -rf of dynamic value. nothing bad happens, right?
  # shellcheck disable=2064
  trap "rm -rf '${SLJAIL_INSTANCE_RUNTIME_DIR}'" EXIT TERM HUP
  bwrap "${bwrap_args[@]}" -- "${program}" "${@}"
else
  # shellcheck disable=2001
  echo "${bwrap_args[@]}" | sed 's/--/\n--/g'
  echo "${program}" "${@}"
fi
